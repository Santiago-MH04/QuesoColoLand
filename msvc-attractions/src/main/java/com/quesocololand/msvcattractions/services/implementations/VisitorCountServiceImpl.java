package com.quesocololand.msvcattractions.services.implementations;

import com.quesocololand.msvcattractions.models.VisitorCount;
import com.quesocololand.msvcattractions.models.dto.GroupedVisitorCountDTO;
import com.quesocololand.msvcattractions.repositories.VisitorCountRepository;
import com.quesocololand.msvcattractions.services.abstractions.VisitorCountService;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Sort;
import org.springframework.data.mongodb.core.MongoTemplate;
import org.springframework.data.mongodb.core.aggregation.*;
import org.springframework.data.mongodb.core.query.Criteria;
import org.springframework.stereotype.Service;

import java.time.*;
import java.util.List;

import static org.springframework.data.mongodb.core.aggregation.Aggregation.*; // For the static methods of de Aggregation

@Service
@RequiredArgsConstructor
public class VisitorCountServiceImpl implements VisitorCountService {
    //Fields of VisitorCountServiceImpl
    private final VisitorCountRepository visitorCountRepo;
    private final MongoTemplate mongoTemplate; // Necessary for aggregation pipelines

    //Methods of VisitorCountServiceImpl
    @Override
    public List<VisitorCount> findByAttractionId(String attractionId) {
        return this.visitorCountRepo.findByAttractionId(attractionId);
    }

    @Override
    public List<VisitorCount> findByTimestampOn(LocalDate date) {

        LocalDateTime startOfDay = date.atStartOfDay();
        LocalDateTime endOfDay = date.atTime(LocalTime.MAX);

        return this.visitorCountRepo.findByTimestampBetween(startOfDay, endOfDay);
    }

    @Override
    public VisitorCount save(VisitorCount visitorCount) {
        return this.visitorCountRepo.save(visitorCount);
    }

    @Override
    public void saveAll(List<VisitorCount> visitorCountList) {
        this.visitorCountRepo.saveAll(visitorCountList);
    }

    @Override
    public List<GroupedVisitorCountDTO> getGroupedVisitorCounts(String attractionId, LocalDate date, int intervalMinutes) {
        // Define the date range for the specific day (from 00:00:00 to 23:59:59)
        LocalDateTime startOfDay = date.atStartOfDay();
        LocalDateTime endOfDay = date.atTime(LocalTime.MAX); // This yields 23:59:59.999999999

        // ---- Aggregation pipeline construction ----
        // 1. $match: to filter by attractionId and date range (using 'timestamp' field)
        MatchOperation matchOperation = match(
            Criteria.where("attractionId").is(attractionId)
                .and("timestamp").gte(startOfDay).lte(endOfDay)
        );

        // 2. $group: to group by the time calculated interval and to sum the counts
        // The most complex part is to calculate the grouping key for the interval.
        ProjectionOperation projectStage = project("timestamp", "count", "attractionId")
            .andExpression("{" +
                "$dateTrunc: {" +
                    "date: '$timestamp'," +
                    "unit: 'minute'," +
                    "binSize: " + intervalMinutes + "," +   // Here goes the magic: it rounds it to the closest interval multiple
                    "timezone: 'America/Bogota'" +
                        /*"timezone: '" + DateOperators.Timezone.valueOf("America/Bogota") + "'" +*/
                "}" +
            "}").as("intervalStart");

        GroupOperation groupOperation = group(
            Fields.fields("intervalStart", "attractionId")
        ).sum("count").as("totalVisitors")  // Maps this sum to totalVisitors
        .first("attractionId").as("attractionId"); // Mantener el attractionId en el resultado


        // 3. $sort: Opcional, to order by interval start
        SortOperation sortOperation = sort(Sort.by(Sort.Order.asc("intervalStart")));

        // 4. $project: formats the output, so it matches with GroupedVisitorCountDTO
        // _id is the field that contains the aggregation key (intervalStart, attractionId)
        ProjectionOperation projectOperation = project()
            .and("$_id.attractionId").as("attractionId")
            .and("$_id.intervalStart").as("intervalStart")
            .and("totalVisitors").as("attendance")
            .andExclude("_id"); // Excludes the field _id generated by $group


        // Build the modular pipeline
        Aggregation aggregation = newAggregation(
            matchOperation,
            projectStage,
            groupOperation,
            sortOperation,
            projectOperation
        );

        // Execute and return the aggregation pipeline
        return this.mongoTemplate.aggregate(
            aggregation,
            "visitor_counts",
            GroupedVisitorCountDTO.class
        ).getMappedResults();
    }
}
